import numpy as np
import matplotlib.pyplot as plt
import os
import jax.numpy as jnp
import json
from ipdb import set_trace

# --- Configuration ---
DATASET_CONFIGS = {
    'imagenet_28_gray': {'input_side': 28, 'num_classes': 1000, 'channels': 1}
}

def get_base_data_jax(dataset_name, root, config, train):
    """
    Loads pre-processed ImageNet dataset from .npy files and converts to JAX Arrays.
    
    Returns:
        X: (N, Flattened_Dim) jax.numpy.array
        Y: (N,) jax.numpy.array
    """
    if dataset_name not in DATASET_CONFIGS:
        raise ValueError(f"Dataset {dataset_name} not found in DATASET_CONFIGS.")

    # Determine split string based on train boolean
    split = 'train' if train else 'test'
    
    # Construct paths to the .npy files generated by prepare_imagenet.py
    x_path = os.path.join(root, f"X_{split}.npy")
    y_path = os.path.join(root, f"Y_{split}.npy")
    
    if not os.path.exists(x_path) or not os.path.exists(y_path):
         raise FileNotFoundError(f"Could not find data files at {x_path} or {y_path}. Did you run prepare_imagenet.py and set the correct root directory?")

    print(f"Loading {dataset_name} (Split={split}) directly from .npy into JAX arrays...")
    
    # Fast Load via Numpy
    X_np = np.load(x_path)
    Y_np = np.load(y_path)
    
    # reshape for CNN
    n_samples = X_np.shape[0]
    X_np = X_np.reshape((n_samples, config.input_side, config.input_side))

    # Convert directly to JAX
    X_jax = jnp.array(X_np)
    Y_jax = jnp.array(Y_np)
    
    return X_jax, Y_jax


def generate_task_class_pairs(num_tasks, n_repeats, num_classes, seed):
    """
    PRE-COMPUTES class pairs for all tasks and repeats following the spec.
    
    Spec Requirement (Section 1):
    "Each repeat samples a random permutation of all available classes without replacement."
    
    Args:
        num_tasks: Number of sequential tasks (T)
        n_repeats: Number of parallel repeats (R)
        num_classes: Total classes in dataset
        seed: Random seed for reproducibility
        
    Returns:
        task_class_pairs: Shape (T, R, 2) - [task_idx, repeat_idx] = (class_A, class_B)
    """
    rng = np.random.default_rng(seed)
    
    # Validate that we can form num_tasks pairs from num_classes
    max_possible_tasks = num_classes // 2
    if num_tasks > max_possible_tasks:
        raise ValueError(
            f"Cannot create {num_tasks} tasks from {num_classes} classes. "
            f"Maximum possible: {max_possible_tasks} tasks."
        )
    
    task_class_pairs = np.zeros((num_tasks, n_repeats, 2), dtype=np.int32)
    
    print(f"\n=== Pre-computing Task Class Pairs ===")
    print(f"Tasks: {num_tasks}, Repeats: {n_repeats}, Classes: {num_classes}")
    
    for r in range(n_repeats):
        # Generate random permutation of all classes for this repeat
        perm = rng.permutation(num_classes)
        
        # Pair consecutive classes: [perm[0], perm[1]], [perm[2], perm[3]], ...
        for t in range(num_tasks):
            class_A = perm[2 * t]
            class_B = perm[2 * t + 1]
            task_class_pairs[t, r, 0] = class_A
            task_class_pairs[t, r, 1] = class_B
            
    return task_class_pairs


def create_single_task_data(task_idx, task_class_pairs, X_global, Y_global, config, split='train'):
    """
    LAZY LOADING: Creates data for a single task on-demand.
    
    Args:
        task_idx: Task index (0-based)
        task_class_pairs: Pre-computed pairs, shape (T, R, 2)
        X_global: Global dataset images (N, Side, Side)
        Y_global: Global dataset labels (N,)
        config: Configuration object
        split: 'train' or 'test'
        
    Returns:
        task_X: (N_samples, R, Side, Side) - Canonical format
        task_Y: (N_samples, R, 1) - Binary labels {0, 1}
        task_name: String identifier
    """
    n_repeats = config.n_repeats
    Y_global_np = np.array(Y_global)
    
    repeat_data_cache = []
    min_samples_in_task = float('inf')

    # Build data for each repeat using pre-computed class pairs
    for r in range(n_repeats):
        class_A = int(task_class_pairs[task_idx, r, 0])
        class_B = int(task_class_pairs[task_idx, r, 1])
        
        # Find indices for both classes
        idx_A = np.where(Y_global_np == class_A)[0]
        idx_B = np.where(Y_global_np == class_B)[0]
        
        # Balance classes
        min_c = min(len(idx_A), len(idx_B))
        
        # Extract data
        x_A = X_global[idx_A[:min_c]]
        x_B = X_global[idx_B[:min_c]]
        
        # Binary labels: class_A -> 0, class_B -> 1 (Spec Section 1)
        y_0 = jnp.zeros((min_c, 1), dtype=jnp.float32)
        y_1 = jnp.ones((min_c, 1), dtype=jnp.float32)
        
        # Concatenate
        x_comb = jnp.concatenate([x_A, x_B], axis=0)
        y_comb = jnp.concatenate([y_0, y_1], axis=0)
        
        # Shuffle within repeat
        perm = np.random.permutation(len(x_comb))
        x_comb = x_comb[perm]
        y_comb = y_comb[perm]
        
        repeat_data_cache.append((x_comb, y_comb))
        min_samples_in_task = min(min_samples_in_task, len(x_comb))

    # Truncate to minimum and stack
    final_x_list = [x[:min_samples_in_task] for x, _ in repeat_data_cache]
    final_y_list = [y[:min_samples_in_task] for _, y in repeat_data_cache]
    
    # Stack: (R, N, Side, Side) -> Transpose to Canonical: (N, R, Side, Side)
    task_X = jnp.stack(final_x_list, axis=0)
    task_Y = jnp.stack(final_y_list, axis=0)
    
    task_X = jnp.swapaxes(task_X, 0, 1)
    task_Y = jnp.swapaxes(task_Y, 0, 1)
    
    task_name = f"task_{task_idx:03d}"
    
    return task_X, task_Y, task_name


def preload_all_test_data(task_class_pairs, X_global, Y_global, config):
    """
    PRE-LOADS all test data as required by spec.
    
    Returns:
        test_data_dict: {task_name: (images, labels)} in Canonical format
    """
    print(f"\n=== Pre-loading ALL Test Data ===")
    test_data_dict = {}
    
    for t in range(config.num_tasks):
        task_X, task_Y, task_name = create_single_task_data(
            t, task_class_pairs, X_global, Y_global, config, split='test'
        )
        test_data_dict[task_name] = (task_X, task_Y)
        print(f"  [{task_name}] Loaded. Shape: {task_X.shape}")
    
    return test_data_dict


def save_task_metadata(task_idx, task_class_pairs, config, additional_info=None):
    """
    Saves metadata.json as specified in Section 4.
    """
    task_dir = os.path.join("results", config.dataset_name, config.algorithm, f"task_{task_idx:03d}")
    os.makedirs(task_dir, exist_ok=True)
    
    # Extract class pairs for this specific task
    pairs_for_task = []
    for r in range(config.n_repeats):
        pairs_for_task.append({
            "repeat": r,
            "class_A": int(task_class_pairs[task_idx, r, 0]),
            "class_B": int(task_class_pairs[task_idx, r, 1])
        })
    
    metadata = {
        "task_id": task_idx,
        "task_name": f"task_{task_idx:03d}",
        "dataset": config.dataset_name,
        "algorithm": config.algorithm,
        "n_repeats": config.n_repeats,
        "task_class_pairs": pairs_for_task,
        "seed": config.seed,
        "hidden_dim": config.hidden_dim,
        "learning_rate1": config.learning_rate1,
        "learning_rate2": config.learning_rate2,
        "batch_size": config.batch_size,
        "epochs_per_task": config.epochs_per_task
    }
    
    if additional_info:
        metadata.update(additional_info)
    
    save_path = os.path.join(task_dir, "metadata.json")
    with open(save_path, 'w') as f:
        json.dump(metadata, f, indent=2)


def save_task_samples_grid(task_class_pairs, X_global, Y_global, config, output_file="task_samples_grid.png"):
    """
    Visualizes task data in a grid.
    Layout: Rows = Repeats, Cols = Tasks * 2 (Class 0, Class 1 pairs).
    """
    n_repeats = config.n_repeats
    num_tasks = config.num_tasks
    
    if num_tasks == 0:
        return

    # 2 Columns per task (one for class 0, one for class 1)
    n_cols = num_tasks * 2
    n_rows = n_repeats
    
    # Calculate figure size (roughly 1.5 inch per subplot)
    fig_width = max(n_cols * 1.5, 6)
    fig_height = max(n_rows * 1.5, 4)
    
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(fig_width, fig_height))
    
    # Standardize axes to always be 2D array
    if n_rows == 1 and n_cols == 1:
        axes = np.array([[axes]])
    elif n_rows == 1:
        axes = axes.reshape(1, -1)
    elif n_cols == 1:
        axes = axes.reshape(-1, 1)

    print(f"\nGenerating task visualization grid ({n_rows}x{n_cols})...")
    
    for t_idx in range(num_tasks):
        # We need the data to find actual images
        task_X, task_Y, task_name = create_single_task_data(
            t_idx, task_class_pairs, X_global, Y_global, config, split='train'
        )
        
        # Convert to numpy for easier indexing
        task_X_np = np.array(task_X) # (N, R, Side, Side)
        task_Y_np = np.array(task_Y) # (N, R, 1)

        for r in range(n_repeats):
            # Original Classes (from metadata)
            class_A = int(task_class_pairs[t_idx, r, 0]) # Maps to L=0
            class_B = int(task_class_pairs[t_idx, r, 1]) # Maps to L=1

            # Get labels for this repeat
            lbls_r = task_Y_np[:, r, 0] # (N,)

            # Find first index of 0 and first index of 1
            idx_0 = np.where(lbls_r == 0)[0]
            idx_1 = np.where(lbls_r == 1)[0]
            
            # Safety check
            if len(idx_0) == 0 or len(idx_1) == 0:
                continue
                
            idx_0 = idx_0[0]
            idx_1 = idx_1[0]
            
            # --- Plot Column 1: Label 0 (Class A) ---
            col_idx_0 = t_idx * 2
            ax0 = axes[r, col_idx_0]
            
            # no longer flat
            img0 = task_X_np[idx_0, r, :]
            # side = int(np.sqrt(img0_flat.shape[0]))
            # img0 = img0_flat.reshape(side, side)
            
            ax0.imshow(img0, cmap='gray')
            ax0.set_xlabel(f"True: {class_A}", fontsize=9)
            
            # --- Plot Column 2: Label 1 (Class B) ---
            col_idx_1 = t_idx * 2 + 1
            ax1 = axes[r, col_idx_1]
            
            img1 = task_X_np[idx_1, r, :]
            # img1 = img1_flat.reshape(side, side)
            
            ax1.imshow(img1, cmap='gray')
            ax1.set_xlabel(f"True: {class_B}", fontsize=9)

            # --- Formatting ---
            
            # Row Labels (Only on first column of the grid)
            if col_idx_0 == 0:
                ax0.set_ylabel(f"Repeat {r}", fontsize=10, fontweight='bold')
            else:
                ax0.set_ylabel("")
            ax1.set_ylabel("")

            # Top Column Headers (Only on first row)
            if r == 0:
                ax0.set_title(f"{task_name}\n(L: 0)", fontsize=10, fontweight='bold')
                ax1.set_title(f"{task_name}\n(L: 1)", fontsize=10, fontweight='bold')
            
            # Remove ticks
            ax0.set_xticks([]); ax0.set_yticks([])
            ax1.set_xticks([]); ax1.set_yticks([])

    plt.tight_layout()
    save_path = os.path.join(config.figures_dir, output_file)
    plt.savefig(save_path, dpi=150)
    plt.close()
    print(f"Saved visualization to {save_path}")